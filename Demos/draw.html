<html>
<head>
<script src="./b64.js"></script>
<script src="../LZWEncoder.js"></script>
<script src="../NeuQuant.js"></script>
<script src="../GIFEncoder.js"></script>

<style>
.frameStrip{
	width:100%;
	background:grey;
	overflow-x:scroll;
}
button{
	width:150px;
}
</style>
</head>
<body>
<button onclick="clearCanv()">Clear Drawing</button>
<button onclick="swapColor()">Swap Color</button>
<br>
<canvas id="bitmap"></canvas>
<canvas id="preview"></canvas>
<img id="image" />
<br>

<button onclick="addFrame()">Add Frame</button>

<button id="prevButton" onclick="preview()">Show Preview</Button>
<button onclick="finish()">Make Gif</Button>
<br>
<button onclick="remFrame()">Remove Last Frame</Button>
<a style="display:none" id="dl" href="#" download="animation.gif">Download Gif file</a>
<div class="asSprite">
<h3>Sprite Frame Strip:</h3>
<div class="frameStrip">
<canvas width=0 id="sprite"></canvas>
</div>
</div>
<div style="display:none" class="asSprite">
<h3>Canvas sprite backup:</h3>
<canvas id="sprite2"></canvas>
</div>
<input id='delay' value="1000"></input>ms
<button onclick='updateTiming()'>apply</button>

</body>
<script>
var CanvasBufferEncoder={
	canvas:undefined,
	context:function(){
		return this.canvas;
	},
	setCanvas:function (c){
		this.canvas=c;
	},
	frameStripCanvas:undefined,
	frameStripBufferCanvas:undefined,
	delay:1000,
	document:undefined,
	stream:undefined,
	getBase64Src:function(){
		return 'data:image/gif;base64,'+encode64(this.stream.getData());
	},
	encode:function encodeSprite(){
		var canvas=this.frameStripCanvas;
		var width=this.canvas.width;

		var encoder = new GIFEncoder();
		encoder.setRepeat(0); //auto-loop
		encoder.setDelay(this.delay);
		encoder.setSize(width,canvas.height);
		console.log(encoder.start());
		for(var i=0;i<canvas.width/width;i++){
			var h = canvas.height;
			var can=this.document.createElement("CANVAS");
			can.height=h;
			can.width=width;
			can.getContext('2d').drawImage(canvas,-i*width,0);
			encoder.addFrame(can.getContext('2d'));
		}
		encoder.setDelay(this.delay);
		encoder.finish();
		this.stream = encoder.stream();
		//document.getElementById('image').src = 'data:image/gif;base64,'+encode64(encoder.stream().getData());
	},
	scount:0,
	addFrame: function (){

		var incWidth=this.canvas.width;
		var ctx = this.context();

		//increase size:
		this.frameStripCanvas.width+=incWidth;

		//repaint old:
		var spritectx = this.frameStripCanvas.getContext('2d');
		if(this.frameStripBufferCanvas.width>0){
			spritectx.drawImage(this.frameStripBufferCanvas,0,0);	
		}
		//paint new:
		spritectx.drawImage(this.canvas,this.scount*incWidth,0);

		//increase size:
		this.frameStripBufferCanvas.width=this.frameStripCanvas.width;
		//paint buffer:
		this.frameStripBufferCanvas.getContext('2d').drawImage(document.getElementById('sprite'),0,0);
		this.scount++;
	},
	remFrame: function(){
		if(this.scount==0)return;
		var incWidth=this.canvas.width;
		var ctx = this.context();
		//encoder.addFrame(ctx);
		//document.getElementById('sprite').width+=100;

		//decrease size:
		this.frameStripCanvas.width-=incWidth;

		//repaint old:
		var spritectx = this.frameStripCanvas.getContext('2d');
		spritectx.drawImage(this.frameStripBufferCanvas,0,0);	
		//paint new:
		//spritectx.drawImage(canvas,scount*incWidth,0);

		//increase size:
		this.frameStripBufferCanvas.width=this.frameStripCanvas.width;
		//paint buffer:
		console.log(this.frameStripBufferCanvas.width);
		if(this.frameStripBufferCanvas.width>0)
			this.frameStripBufferCanvas.getContext('2d').drawImage(document.getElementById('sprite'),0,0);
		this.scount--;
	},
	init:function(watchCanvas, stripCanvas, bufferCanvas, previewCanvas){
		this.canvas = watchCanvas;
		this.frameStripCanvas = stripCanvas;
		this.frameStripBufferCanvas = bufferCanvas;
		this.previewCanvas=previewCanvas;
		this.document=document;
	},
	inst:0,
	previewCanvas:undefined,
	setPreview : function(bol){
		console.log("called");
		this.inst++;
		if(bol){
			var canvas = this.frameStripCanvas;
			var parent = this;
			var cur =parent.inst;
			var can = this.previewCanvas;
			var h = this.canvas.height;
			can.height=h;
			can.width=this.canvas.width;
			var i=0;
			var drawFrame=function(){
				console.log("draw" + cur + " ?= " + parent.inst);
				if(cur==parent.inst){
					if(canvas.width>0){
						can.getContext('2d').drawImage(canvas,-i*can.width,0);
						i++;
						if(i>=canvas.width/can.width){
							i=0;
						}
					}
					setTimeout(arguments.callee,parent.delay);
				}
		
			}; 
			drawFrame();
		}
	}
};

//init:
var canvas = document.getElementById('bitmap');
var context = canvas.getContext('2d');
canvas.width = 150;
canvas.height = 150;

function updateTiming(){
	CanvasBufferEncoder.delay=document.getElementById("delay").value;
}
function finish(){
	CanvasBufferEncoder.encode();
	document.getElementById('image').src =CanvasBufferEncoder.getBase64Src();
	document.getElementById("dl").href=document.getElementById("image").src;
	document.getElementById("dl").download="animated.gif";
	document.getElementById("dl").style="";
}
function preview(){
	var ctext=document.getElementById('prevButton').innerHTML;
	if(ctext == "Show Preview"){
		document.getElementById('prevButton').innerHTML="Hide Preview";
		CanvasBufferEncoder.setPreview(true);
	}else{
		document.getElementById('prevButton').innerHTML="Show Preview";
		CanvasBufferEncoder.setPreview(false);
	}

}
function addFrame(){
	CanvasBufferEncoder.addFrame();
}
function remFrame(){
	CanvasBufferEncoder.remFrame();
}

//based on: https://developer.mozilla.org/en/Canvas_tutorial/Basic_animations#An_animation_example_2
function clock(now){
  var ctx = context;
  ctx.save();
  context.fillStyle = "rgb(255,255,255)";  
  context.fillRect(0,0,150, 150); //GIF can't do transparent so do white

  ctx.translate(75,75);
  ctx.scale(0.4,0.4);
  ctx.rotate(-Math.PI/2);
  ctx.strokeStyle = "black";
  ctx.fillStyle = "white";
  ctx.lineWidth = 8;
  ctx.lineCap = "round";

  // Hour marks
  ctx.save();
  for (var i=0;i<12;i++){
    ctx.beginPath();
    ctx.rotate(Math.PI/6);
    ctx.moveTo(100,0);
    ctx.lineTo(120,0);
    ctx.stroke();
  }
  ctx.restore();

  // Minute marks
  ctx.save();
  ctx.lineWidth = 5;
  for (i=0;i<60;i++){
    if (i%5!=0) {
      ctx.beginPath();
      ctx.moveTo(117,0);
      ctx.lineTo(120,0);
      ctx.stroke();
    }
    ctx.rotate(Math.PI/30);
  }
  ctx.restore();
  
  var sec = now.getSeconds();
  var min = now.getMinutes();
  var hr  = now.getHours();
  hr = hr>=12 ? hr-12 : hr;

  ctx.fillStyle = "black";

  // write Hours
  ctx.save();
  ctx.rotate( hr*(Math.PI/6) + (Math.PI/360)*min + (Math.PI/21600)*sec )
  ctx.lineWidth = 14;
  ctx.beginPath();
  ctx.moveTo(-20,0);
  ctx.lineTo(80,0);
  ctx.stroke();
  ctx.restore();

  // write Minutes
  ctx.save();
  ctx.rotate( (Math.PI/30)*min + (Math.PI/1800)*sec )
  ctx.lineWidth = 10;
  ctx.beginPath();
  ctx.moveTo(-28,0);
  ctx.lineTo(112,0);
  ctx.stroke();
  ctx.restore();
  
  // Write seconds
  ctx.save();
  ctx.rotate(sec * Math.PI/30);
  ctx.strokeStyle = "#D40000";
  ctx.fillStyle = "#D40000";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(-30,0);
  ctx.lineTo(83,0);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0,0,10,0,Math.PI*2,true);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(95,0,10,0,Math.PI*2,true);
  ctx.stroke();
  ctx.fillStyle = "#555";
  ctx.arc(0,0,3,0,Math.PI*2,true);
  ctx.fill();
  ctx.restore();

  ctx.beginPath();
  ctx.lineWidth = 14;
  ctx.strokeStyle = '#325FA2';
  ctx.arc(0,0,142,0,Math.PI*2,true);
  ctx.stroke();

  ctx.restore();
  //addFrame();
}

CanvasBufferEncoder.init(canvas,
document.getElementById("sprite"),
document.getElementById("sprite2"),
document.getElementById("preview")
);

clock(new Date());
setInterval(function(){
	//clock(new Date());
},1000);
preview();

var SignaturePad = (function (document) {
    "use strict";

    var SignaturePad = function (canvas, options) {
        var self = this,
            opts = options || {};

        this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
        this.minWidth = opts.minWidth || 0.5;
        this.maxWidth = opts.maxWidth || 2.5;
        this.dotSize = opts.dotSize || function () {
            return (this.minWidth + this.maxWidth) / 2;
        };
        this.penColor = opts.penColor || "black";
        this.backgroundColor = opts.backgroundColor || "rgba(0,0,0,0)";
        this.onEnd = opts.onEnd;
        this.onBegin = opts.onBegin;

        this._canvas = canvas;
        this._ctx = canvas.getContext("2d");
        this.clear();

        this._handleMouseEvents();
        this._handleTouchEvents();
    };

    SignaturePad.prototype.clear = function () {
        var ctx = this._ctx,
            canvas = this._canvas;

        ctx.fillStyle = this.backgroundColor;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._reset();
    };

    SignaturePad.prototype._strokeUpdate = function (event) {
        var point = this._createPoint(event);
        this._addPoint(point);
    };

    SignaturePad.prototype._strokeBegin = function (event) {
        this._reset();
        this._strokeUpdate(event);
        if (typeof this.onBegin === 'function') {
            this.onBegin(event);
        }
    };

    SignaturePad.prototype._strokeDraw = function (point) {
        var ctx = this._ctx,
            dotSize = typeof(this.dotSize) === 'function' ? this.dotSize() : this.dotSize;

        ctx.beginPath();
        this._drawPoint(point.x, point.y, dotSize);
        ctx.closePath();
        ctx.fill();
    };

    SignaturePad.prototype._strokeEnd = function (event) {
        var canDrawCurve = this.points.length > 2,
            point = this.points[0];

        if (!canDrawCurve && point) {
            this._strokeDraw(point);
        }
        if (typeof this.onEnd === 'function') {
            this.onEnd(event);
        }
    };

    SignaturePad.prototype._handleMouseEvents = function () {
        var self = this;
        this._mouseButtonDown = false;
	this.ctrl=false;
        this._canvas.addEventListener("mousedown", function (event) {
		console.log(event);

            if (event.which === 1) {
		if(event.ctrlKey){
			self.ctrl = true;
			self.swapColors();
		}else{
			self.ctrl=false;
		}
                self._mouseButtonDown = true;
                self._strokeBegin(event);
            }
        });

        this._canvas.addEventListener("mousemove", function (event) {
            if (self._mouseButtonDown) {
                self._strokeUpdate(event);
            }
        });

        document.addEventListener("mouseup", function (event) {
            if (event.which === 1 && self._mouseButtonDown) {
                self._mouseButtonDown = false;
                self._strokeEnd(event);
		if(self.ctrl){
			self.swapColors();
			self.ctrl=false;
		}
            }
        });
    };

    SignaturePad.prototype._handleTouchEvents = function () {
        var self = this;

        // Pass touch events to canvas element on mobile IE.
        this._canvas.style.msTouchAction = 'none';

        this._canvas.addEventListener("touchstart", function (event) {
            var touch = event.changedTouches[0];
            self._strokeBegin(touch);
        });

        this._canvas.addEventListener("touchmove", function (event) {
            // Prevent scrolling.
            event.preventDefault();

            var touch = event.changedTouches[0];
            self._strokeUpdate(touch);
        });

        document.addEventListener("touchend", function (event) {
            var wasCanvasTouched = event.target === self._canvas;
            if (wasCanvasTouched) {
                self._strokeEnd(event);
            }
        });
    };

    SignaturePad.prototype.isEmpty = function () {
        return this._isEmpty;
    };

    SignaturePad.prototype._reset = function () {
        this.points = [];
        this._lastVelocity = 0;
        this._lastWidth = (this.minWidth + this.maxWidth) / 2;
        this._isEmpty = true;
        this._ctx.fillStyle = this.penColor;
    };

    SignaturePad.prototype._createPoint = function (event) {
        var rect = this._canvas.getBoundingClientRect();
        return new Point(
            event.clientX - rect.left,
            event.clientY - rect.top
        );
    };

    SignaturePad.prototype._addPoint = function (point) {
        var points = this.points,
            c2, c3,
            curve, tmp;

        points.push(point);

        if (points.length > 2) {
            // To reduce the initial lag make it work with 3 points
            // by copying the first point to the beginning.
            if (points.length === 3) points.unshift(points[0]);

            tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
            c2 = tmp.c2;
            tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
            c3 = tmp.c1;
            curve = new Bezier(points[1], c2, c3, points[2]);
            this._addCurve(curve);

            // Remove the first element from the list,
            // so that we always have no more than 4 points in points array.
            points.shift();
        }
    };
    SignaturePad.prototype.swapColors = function(){
	var pcolor = this.penColor;	
	this.penColor = this.backgroundColor ;
        this.backgroundColor = pcolor;
    };
    SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
        var dx1 = s1.x - s2.x, dy1 = s1.y - s2.y,
            dx2 = s2.x - s3.x, dy2 = s2.y - s3.y,

            m1 = {x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0},
            m2 = {x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0},

            l1 = Math.sqrt(dx1*dx1 + dy1*dy1),
            l2 = Math.sqrt(dx2*dx2 + dy2*dy2),

            dxm = (m1.x - m2.x),
            dym = (m1.y - m2.y),

            k = l2 / (l1 + l2),
            cm = {x: m2.x + dxm*k, y: m2.y + dym*k},

            tx = s2.x - cm.x,
            ty = s2.y - cm.y;

        return {
            c1: new Point(m1.x + tx, m1.y + ty),
            c2: new Point(m2.x + tx, m2.y + ty)
        };
    };

    SignaturePad.prototype._addCurve = function (curve) {
        var startPoint = curve.startPoint,
            endPoint = curve.endPoint,
            velocity, newWidth;

        velocity = endPoint.velocityFrom(startPoint);
        velocity = this.velocityFilterWeight * velocity
            + (1 - this.velocityFilterWeight) * this._lastVelocity;

        newWidth = this._strokeWidth(velocity);
        this._drawCurve(curve, this._lastWidth, newWidth);

        this._lastVelocity = velocity;
        this._lastWidth = newWidth;
    };

    SignaturePad.prototype._drawPoint = function (x, y, size) {
        var ctx = this._ctx;

        ctx.moveTo(x, y);
        ctx.arc(x, y, size, 0, 2 * Math.PI, false);
        this._isEmpty = false;
    };

    SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
        var ctx = this._ctx,
            widthDelta = endWidth - startWidth,
            drawSteps, width, i, t, tt, ttt, u, uu, uuu, x, y;

        drawSteps = Math.floor(curve.length());
        ctx.beginPath();
        for (i = 0; i < drawSteps; i++) {
            // Calculate the Bezier (x, y) coordinate for this step.
            t = i / drawSteps;
            tt = t * t;
            ttt = tt * t;
            u = 1 - t;
            uu = u * u;
            uuu = uu * u;

            x = uuu * curve.startPoint.x;
            x += 3 * uu * t * curve.control1.x;
            x += 3 * u * tt * curve.control2.x;
            x += ttt * curve.endPoint.x;

            y = uuu * curve.startPoint.y;
            y += 3 * uu * t * curve.control1.y;
            y += 3 * u * tt * curve.control2.y;
            y += ttt * curve.endPoint.y;

            width = startWidth + ttt * widthDelta;
            this._drawPoint(x, y, width);
        }
        ctx.closePath();
        ctx.fill();
    };

    SignaturePad.prototype._strokeWidth = function (velocity) {
        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
    };


    var Point = function (x, y, time) {
        this.x = x;
        this.y = y;
        this.time = time || new Date().getTime();
    };

    Point.prototype.velocityFrom = function (start) {
        return (this.time !== start.time) ? this.distanceTo(start) / (this.time - start.time) : 1;
    };

    Point.prototype.distanceTo = function (start) {
        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
    };

    var Bezier = function (startPoint, control1, control2, endPoint) {
        this.startPoint = startPoint;
        this.control1 = control1;
        this.control2 = control2;
        this.endPoint = endPoint;
    };

    // Returns approximated length.
    Bezier.prototype.length = function () {
        var steps = 10,
            length = 0,
            i, t, cx, cy, px, py, xdiff, ydiff;

        for (i = 0; i <= steps; i++) {
            t = i / steps;
            cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
            cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
            if (i > 0) {
                xdiff = cx - px;
                ydiff = cy - py;
                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            }
            px = cx;
            py = cy;
        }
        return length;
    };

    Bezier.prototype._point = function (t, start, c1, c2, end) {
        return          start * (1.0 - t) * (1.0 - t)  * (1.0 - t)
               + 3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t
               + 3.0 *  c2    * (1.0 - t) * t          * t
               +        end   * t         * t          * t;
    };

    return SignaturePad;
})(document);
signaturePad=new SignaturePad(canvas);
signaturePad.penColor="red";
signaturePad.backgroundColor="white";
context.fillStyle = "rgb(255,255,255)";  
context.fillRect(0,0,canvas.width, canvas.height); //GIF can't do transparent so do white
function clearCanv(){
	console.log("clear");
	context.fillStyle = "rgb(255,255,255)";  
	context.fillRect(0,0,canvas.width, canvas.height); //GIF can't do transparent so do white
}
function swapColor(){
	signaturePad.swapColors();
}
document.addEventListener("keydown", function (event) {
		if(event.which==32){
			addFrame();
		}
        });

</script>
</html>
